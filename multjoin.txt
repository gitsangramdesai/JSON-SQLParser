// --- 1. REGISTRIES ---
const sqlFunctions = {
    "upper": (args) => String(args[0] ?? "").toUpperCase(),
    "lower": (args) => String(args[0] ?? "").toLowerCase(),
    // Updated Aggregates to be Null-Aware
    "sum": (values) => {
        const valid = values.filter(v => v !== null && v !== "NULL" && v !== undefined);
        return valid.reduce((a, b) => a + (Number(b) || 0), 0);
    },
    "count": (values) => {
        // Standard SQL COUNT(column) ignores NULLs
        return values.filter(v => v !== null && v !== "NULL" && v !== undefined).length;
    },
    "avg": (values) => {
        const valid = values.filter(v => v !== null && v !== "NULL" && v !== undefined);
        return valid.length ? (valid.reduce((a, b) => a + (Number(b) || 0), 0) / valid.length) : 0;
    },
    "min": (values) => {
        const valid = values.filter(v => v !== null && v !== "NULL" && v !== undefined).map(Number);
        return valid.length ? Math.min(...valid) : "NULL";
    },
    "max": (values) => {
        const valid = values.filter(v => v !== null && v !== "NULL" && v !== undefined).map(Number);
        return valid.length ? Math.max(...valid) : "NULL";
    },
    "coalesce": (args) => {    // Return the first argument that isn't NULL or empty
        return args.find(v => v !== null && v !== "NULL" && v !== undefined && v !== "") ?? "NULL";
    }
};
function splitArgs(argsStr) {
    let result = [], depth = 0, buf = "";
    for (let ch of argsStr) {
        if (ch === "(") depth++;
        else if (ch === ")") depth--;
        if (ch === "," && depth === 0) {
            result.push(buf.trim());
            buf = "";
        } else buf += ch;
    }
    if (buf) result.push(buf.trim());
    return result;
}
// --- 2. HELPERS ---
function resolvePath(path, scope) {
    if (!path) return null;
    const parts = path.split('.');
    let current = scope;
    for (let part of parts) {
        const key = part.startsWith('$') ? part.slice(1) : part;
        if (current === scope && current[key] === undefined && (key === 'data' || key === 'root')) continue;
        current = current?.[key];
    }
    return current;
}

// --- 3. PARSER ---
// --- 3. UPDATED PARSER ---
function parseAlias(token) {
    const parts = token.split(/\s+as\s+/i);
    return parts.length === 2 ? { expr: parts[0].trim(), alias: parts[1].trim() } : { expr: token, alias: token };
}

function getSelectTokensFromPart(expr) {
    let result = [], depth = 0, buf = "";
    for (let ch of expr) {
        if (ch === "(") depth++; else if (ch === ")") depth--;
        if (ch === "," && depth === 0) { result.push(parseAlias(buf.trim())); buf = ""; } else buf += ch;
    }
    if (buf) result.push(parseAlias(buf.trim()));
    return result;
}

function findTopLevelClause(sqlLower, keyword) {
    let depth = 0;
    for (let i = 0; i < sqlLower.length; i++) {
        if (sqlLower[i] === '(') depth++;
        else if (sqlLower[i] === ')') depth--;
        if (depth === 0 && sqlLower.startsWith(keyword, i)) return i;
    }
    return -1;
}

/**
 * Helper to find keywords only when they are not nested inside parentheses.
 * This prevents splitting on keywords inside functions like COALESCE() or RANK().
 */
function findTopLevelClause(sql, clause) {
    const tokens = sql.split(/\s+/);
    let depth = 0;
    let index = 0;
    const lowerSql = sql.toLowerCase();
    const search = clause.toLowerCase();

    for (let i = 0; i < sql.length; i++) {
        if (sql[i] === '(') depth++;
        if (sql[i] === ')') depth--;
        if (depth === 0 && lowerSql.startsWith(search, i)) {
            // Check boundaries to ensure it's a whole word
            const before = i === 0 || /\s/.test(sql[i - 1]);
            const after = /\s/.test(sql[i + search.length]) || i + search.length === sql.length;
            if (before && after) return i;
        }
    }
    return -1;
}

/**
 * Main Parser Function
 */
function parseSQL(sql) {
    // Basic cleanup
    sql = sql.trim().replace(/;$/, '').replace(/\s+/g, ' ');
    const lower = sql.toLowerCase();

    // 1. Locate main clauses
    const sIdx = findTopLevelClause(lower, "select");
    const fIdx = findTopLevelClause(lower, "from");
    const wIdx = findTopLevelClause(lower, "where");
    const gIdx = findTopLevelClause(lower, "group by");
    const oIdx = findTopLevelClause(lower, "order by");
    const lIdx = findTopLevelClause(lower, "limit");

    if (sIdx === -1 || fIdx === -1) {
        throw new Error("Invalid SQL: Must contain SELECT and FROM clauses.");
    }

    // 2. Determine boundaries for extracting strings
    const getEnd = (start) => {
        const boundaries = [wIdx, gIdx, oIdx, lIdx].filter(i => i > start);
        return boundaries.length > 0 ? Math.min(...boundaries) : sql.length;
    };

    // 3. Parse SELECT (Handle DISTINCT and Tokens)
    let selectPartRaw = sql.slice(sIdx + 6, fIdx).trim();
    const isDistinct = selectPartRaw.toLowerCase().startsWith("distinct");
    if (isDistinct) selectPartRaw = selectPartRaw.slice(8).trim();

    // Split select tokens by comma, ignoring commas inside parentheses
    const selectTokens = [];
    let depth = 0, current = "";
    for (let i = 0; i < selectPartRaw.length; i++) {
        const char = selectPartRaw[i];
        if (char === '(') depth++;
        if (char === ')') depth--;
        if (char === ',' && depth === 0) {
            selectTokens.push(parseToken(current.trim()));
            current = "";
        } else current += char;
    }
    selectTokens.push(parseToken(current.trim()));

    // 4. Parse FROM & JOINS (The Chain Logic)
    const fromSection = sql.slice(fIdx + 4, getEnd(fIdx)).trim();
    const joinParts = fromSection.split(/\sjoin\s/i);
    const baseTable = joinParts[0].trim();
    const joins = [];

    for (let i = 1; i < joinParts.length; i++) {
        const joinSegment = joinParts[i]; 
        // Detect if the previous part ended with "LEFT"
        const isLeft = joinParts[i-1].toLowerCase().trim().endsWith("left");
        
        const onIdx = joinSegment.toLowerCase().indexOf(" on ");
        if (onIdx === -1) throw new Error("JOIN missing ON condition");
        
        const tablePath = joinSegment.slice(0, onIdx).trim();
        const condition = joinSegment.slice(onIdx + 4).trim();
        
        joins.push({ tablePath, condition, isLeft });
    }

    // 5. Final Return Object
    return {
        selectTokens,
        isDistinct,
        baseTable,
        joins,
        whereClause: wIdx !== -1 ? sql.slice(wIdx + 6, getEnd(wIdx)).trim() : null,
        groupBy: gIdx !== -1 ? sql.slice(gIdx + 8, getEnd(gIdx)).trim() : null,
        orderClause: oIdx !== -1 ? sql.slice(oIdx + 9, getEnd(oIdx)).trim() : null,
        limit: lIdx !== -1 ? parseInt(sql.slice(lIdx + 5).trim()) : null
    };
}

/**
 * Helper to identify if a SELECT token is an aggregate, window, or scalar
 */
function parseToken(raw) {
    const aliasMatch = raw.match(/(.+) as (.+)/i);
    const expr = aliasMatch ? aliasMatch[1].trim() : raw;
    const alias = aliasMatch ? aliasMatch[2].trim() : expr.split('.').pop();

    const isAggregate = /^(sum|avg|count|min|max)\(/i.test(expr);
    const isWindow = /over\s*\(/i.test(expr);

    let windowType = null, partitionBy = null, windowOrder = null;
    if (isWindow) {
        windowType = expr.match(/^(\w+)/i)[0].toLowerCase();
        const overMatch = expr.match(/over\s*\((.*)\)/i)[1];
        const partMatch = overMatch.match(/partition by\s+([^order]+)/i);
        const orderMatch = overMatch.match(/order by\s+(.*)/i);
        partitionBy = partMatch ? partMatch[1].trim() : null;
        windowOrder = orderMatch ? orderMatch[1].trim() : null;
    }

    let aggFunc = null, aggColumn = null;
    if (isAggregate) {
        const match = expr.match(/^(\w+)\((.*)\)/i);
        aggFunc = match[1].toLowerCase();
        aggColumn = match[2].trim() === "*" ? null : match[2].trim();
    }

    return { expr, alias, isAggregate, aggFunc, aggColumn, isWindow, windowType, partitionBy, windowOrder };
}

// --- 4. UPDATED ENGINE CORE ---

/**
 * Helper: Parses "col1 ASC, col2 DESC" into an array of objects.
 */
function parseOrderParams(orderClause) {
    if (!orderClause) return [];
    return orderClause.split(",").map(p => {
        const t = p.trim().split(/\s+/);
        return { expr: t[0].trim(), dir: (t[1] || "ASC").toUpperCase() };
    });
}

/**
 * Helper: Sorts an array of objects based on parsed order parameters.
 */
function applyOrderBy(rows, orderClause) {
    if (!orderClause) return rows;
    const orders = parseOrderParams(orderClause);

    return [...rows].sort((a, b) => {
        for (const { expr, dir } of orders) {
            let av = a[expr], bv = b[expr];
            // Attempt numeric conversion for correct sorting
            if (!isNaN(av) && !isNaN(bv) && av !== "" && bv !== "") {
                av = Number(av);
                bv = Number(bv);
            }
            if (av < bv) return dir === "ASC" ? -1 : 1;
            if (av > bv) return dir === "ASC" ? 1 : -1;
        }
        return 0;
    });
}
/**
 * Helper: Checks if two rows are identical based on the ORDER BY columns.
 * Used to detect ties for RANK and DENSE_RANK.
 */
function areRowsTied(rowA, rowB, orderParams) {
    if (!rowB) return false; // First row has no predecessor
    for (const { expr } of orderParams) {
        if (rowA[expr] != rowB[expr]) return false;
    }
    return true;
}

/**
 * MAIN EXECUTION FUNCTION
 */
function executeQuery(sql, rootData) {
    const parsed = parseSQL(sql);

    // --- HELPER: COMBINE ROWS & NAMESPACE ---
    const combineRows = (existingRow, newMatch, nextTableName, rightTemplate = {}) => {
        const namespacedMatch = {};
        if (newMatch) {
            // Map new table columns to nextTable.column
            Object.keys(newMatch).forEach(k => namespacedMatch[`${nextTableName}.${k}`] = newMatch[k]);
            return { ...existingRow, ...newMatch, ...namespacedMatch };
        } else {
            // Handle NULL-fill for LEFT JOIN
            const nulls = {};
            Object.keys(rightTemplate).forEach(k => {
                nulls[k] = "NULL";
                namespacedMatch[`${nextTableName}.${k}`] = "NULL";
            });
            return { ...existingRow, ...nulls, ...namespacedMatch };
        }
    };

    // --- 1. DATA LOADING & MULTI-JOIN ---
    let rows = [];
    const baseData = resolvePath(parsed.baseTable, rootData);
    if (!baseData) throw new Error(`Table not found: ${parsed.baseTable}`);

    // Initial Namespacing for the Base Table
    const baseName = parsed.baseTable.split('.').pop();
    rows = baseData.map(r => {
        const namespaced = {};
        Object.keys(r).forEach(k => namespaced[`${baseName}.${k}`] = r[k]);
        return { ...r, ...namespaced };
    });

    // Process the Join Chain
    parsed.joins.forEach(joinDef => {
        const nextTableData = resolvePath(joinDef.tablePath, rootData);
        if (!nextTableData) throw new Error(`Table not found: ${joinDef.tablePath}`);
        
        const nextTableName = joinDef.tablePath.split('.').pop();
        const opMatch = joinDef.condition.match(/(=|>|<|>=|<=|!=)/);
        if (!opMatch) throw new Error("Invalid JOIN condition");
        
        const operator = opMatch[0];
        const [leftCol, rightCol] = joinDef.condition.split(operator).map(c => c.trim());
        const newRows = [];

        // STRATEGY: Hash Join (for =) or Nested Loop (for inequalities)
        if (operator === '=') {
            const rightMap = new Map();
            nextTableData.forEach(r => {
                const key = String(r[rightCol]);
                if (!rightMap.has(key)) rightMap.set(key, []);
                rightMap.get(key).push(r);
            });

            rows.forEach(existingRow => {
                const lookupKey = String(existingRow[leftCol] ?? "NULL");
                const matches = rightMap.get(lookupKey);
                if (matches) {
                    matches.forEach(m => newRows.push(combineRows(existingRow, m, nextTableName)));
                } else if (joinDef.isLeft) {
                    newRows.push(combineRows(existingRow, null, nextTableName, nextTableData[0] || {}));
                }
            });
        } else {
            // Nested Loop fallback for theta joins (>, <, etc)
            rows.forEach(existingRow => {
                let foundMatch = false;
                nextTableData.forEach(m => {
                    const lVal = existingRow[leftCol];
                    const rVal = m[rightCol];
                    let isMatch = false;
                    if (operator === '>') isMatch = lVal > rVal;
                    else if (operator === '<') isMatch = lVal < rVal;
                    else if (operator === '>=') isMatch = lVal >= rVal;
                    else if (operator === '<=') isMatch = lVal <= rVal;
                    else if (operator === '!=') isMatch = lVal != rVal;

                    if (isMatch) {
                        foundMatch = true;
                        newRows.push(combineRows(existingRow, m, nextTableName));
                    }
                });
                if (!foundMatch && joinDef.isLeft) {
                    newRows.push(combineRows(existingRow, null, nextTableName, nextTableData[0] || {}));
                }
            });
        }
        rows = newRows; 
    });

    // --- 2. WHERE FILTERING ---
    if (parsed.whereClause) {
        rows = rows.filter(r => evaluateCondition(r, parsed.whereClause));
    }

    // --- 3. WINDOW FUNCTIONS ---
    parsed.selectTokens.filter(t => t.isWindow).forEach(t => {
        const partitions = {};
        const partCols = t.partitionBy ? t.partitionBy.split(',').map(c => c.trim()) : [];
        rows.forEach(r => {
            const key = partCols.map(col => String(r[col] ?? "NULL")).join('|');
            if (!partitions[key]) partitions[key] = [];
            partitions[key].push(r);
        });
        Object.values(partitions).forEach(pRows => {
            const sorted = applyOrderBy(pRows, t.windowOrder);
            const orderParams = parseOrderParams(t.windowOrder);
            sorted.forEach((r, idx) => {
                if (t.windowType === 'row_number') r[t.alias] = idx + 1;
                else if (t.windowType === 'rank' || t.windowType === 'dense_rank') {
                    if (idx === 0) r[t.alias] = 1;
                    else {
                        const isTie = areRowsTied(r, sorted[idx - 1], orderParams);
                        if (t.windowType === 'rank') {
                            r[t.alias] = isTie ? sorted[idx - 1][t.alias] : idx + 1;
                        } else {
                            r[t.alias] = isTie ? sorted[idx - 1][t.alias] : (sorted[idx - 1][t.alias] + 1);
                        }
                    }
                }
            });
        });
    });

    // --- 4. GROUP BY & AGGREGATES ---
    if (parsed.groupBy) {
        const groups = {};
        const groupCols = parsed.groupBy.split(',').map(c => c.trim());
        rows.forEach(row => {
            const key = groupCols.map(col => String(row[col] ?? "NULL")).join('|');
            if (!groups[key]) groups[key] = { baseRow: { ...row }, aggValues: {} };
            parsed.selectTokens.filter(t => t.isAggregate).forEach(t => {
                if (!groups[key].aggValues[t.alias]) groups[key].aggValues[t.alias] = [];
                groups[key].aggValues[t.alias].push(t.aggColumn ? row[t.aggColumn] : 1);
            });
        });
        rows = Object.values(groups).map(group => {
            const finalRow = { ...group.baseRow };
            parsed.selectTokens.filter(t => t.isAggregate).forEach(t => {
                finalRow[t.alias] = sqlFunctions[t.aggFunc](group.aggValues[t.alias]);
            });
            return finalRow;
        });
    }

    // --- 5. GLOBAL ORDER BY ---
    if (parsed.orderClause) rows = applyOrderBy(rows, parsed.orderClause);

    // --- 6. FINAL PROJECTION (Scalar Functions + Logic) ---
    const finalAliases = parsed.selectTokens.map(t => t.alias);
    let result = rows.map(row => {
        const clean = {};
        parsed.selectTokens.forEach(t => {
            const funcMatch = t.expr.match(/^(\w+)\((.*)\)$/);
            if (funcMatch && !t.isAggregate && !t.isWindow) {
                const funcName = funcMatch[1].toLowerCase();
                const argsRaw = splitArgs(funcMatch[2]);
                const resolvedArgs = argsRaw.map(arg => {
                    const isLiteral = /^['"].*['"]$/.test(arg);
                    if (isLiteral) return arg.replace(/['"]/g, '');
                    return row[arg] !== undefined ? row[arg] : null;
                });
                clean[t.alias] = sqlFunctions[funcName] ? sqlFunctions[funcName](resolvedArgs) : "NULL";
            } else {
                const val = row[t.alias] !== undefined ? row[t.alias] : row[t.expr];
                clean[t.alias] = (val !== undefined && val !== null) ? val : "NULL";
            }
        });
        return clean;
    });

    // --- 6.5 DISTINCT ---
    if (parsed.isDistinct) {
        const seen = new Set();
        result = result.filter(row => {
            const key = JSON.stringify(row);
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }

    // --- 7. LIMIT ---
    if (parsed.limit !== null && !isNaN(parsed.limit)) {
        return result.slice(0, parsed.limit);
    }

    return result;
}
// --- 4. ENGINE CORE ---
function applyOrderBy(rows, orderClause) {
    if (!orderClause) return rows;
    const orders = orderClause.split(",").map(p => {
        const t = p.trim().split(/\s+/);
        return { expr: t[0].trim(), dir: (t[1] || "ASC").toUpperCase() };
    });
    return [...rows].sort((a, b) => {
        for (const { expr, dir } of orders) {
            let av = a[expr], bv = b[expr];
            if (!isNaN(av) && !isNaN(bv)) { av = Number(av); bv = Number(bv); }
            if (av < bv) return dir === "ASC" ? -1 : 1;
            if (av > bv) return dir === "ASC" ? 1 : -1;
        }
        return 0;
    });
}

function evaluateCondition(row, condition) {
    if (!condition) return true;

    // Split by " AND " (case insensitive)
    const parts = condition.split(/\s+and\s+/i);

    return parts.every(part => {
        const match = part.match(/(\w+)\s*(=|>|<|!=)\s*(.*)/);
        if (!match) return true;

        let [_, col, op, val] = match;
        let rowVal = row[col];

        // Clean up quotes from the SQL string: 'New York' -> New York
        val = val.trim().replace(/['"]/g, '');

        // Numeric Comparison
        if (!isNaN(rowVal) && !isNaN(val) && rowVal !== "" && val !== "") {
            rowVal = Number(rowVal);
            val = Number(val);
        }

        switch (op) {
            case '=': return String(rowVal) === String(val);
            case '>': return rowVal > val;
            case '<': return rowVal < val;
            case '!=': return rowVal != val;
            default: return true;
        }
    });
}

// Helper to keep the code clean
function combineRows(lRow, rRow, leftName, rightName, rightTemplate = {}) {
    const combined = { ...lRow };
    const namespaced = {};
    Object.keys(lRow).forEach(k => namespaced[`${leftName}.${k}`] = lRow[k]);
    
    if (rRow) {
        Object.assign(combined, rRow);
        Object.keys(rRow).forEach(k => namespaced[`${rightName}.${k}`] = rRow[k]);
    } else {
        // Handle NULL side for LEFT JOIN
        Object.keys(rightTemplate).forEach(k => namespaced[`${rightName}.${k}`] = "NULL");
    }
    return { ...combined, ...namespaced };
}

// Add to parseSQL or a helper
function parseJoin(fromSegment) {
    const joinMatch = fromSegment.match(/(.+)[\s\S]+join[\s\S]+(.+)[\s\S]+on[\s\S]+(.+)/i);
    if (!joinMatch) return { table: fromSegment.trim(), joinTable: null };

    return {
        table: joinMatch[1].trim(),
        joinTable: joinMatch[2].trim(),
        joinCondition: joinMatch[3].trim() // e.g. "friends.city = cities.name"
    };
}

// --- FORMATTER ---
function formatAsMySQLTable(rows) {
    if (!rows.length) return "Empty set";
    const columns = Object.keys(rows[0]);
    const widths = {};
    columns.forEach(col => widths[col] = Math.max(col.length, ...rows.map(r => String(r[col] ?? "").length)));
    const line = () => "+" + columns.map(c => "-".repeat(widths[c] + 2)).join("+") + "+";

    // Inside formatAsMySQLTable
    const rowStr = (vals) => "| " + vals.map((v, i) => {
        const displayVal = v === null ? "NULL" : String(v); // Explicitly print NULL
        return displayVal.padEnd(widths[columns[i]]);
    }).join(" | ") + " |";

    let output = line() + "\n" + rowStr(columns) + "\n" + line() + "\n";
    rows.forEach(r => output += rowStr(columns.map(c => r[c])) + "\n");
    return output + line();
}

// --- DATA ---



const data = {
    friends: [
        { name: "Chris", city: "New York", countryCode: "USA" },
        { name: "Emily", city: "Atlanta", countryCode: "USA" },
        { name: "Yuki", city: "Tokyo", countryCode: "JPN" }
    ],
    cities: [
        { cityName: "New York", state: "NY" },
        { cityName: "Atlanta", state: "GA" },
        { cityName: "Tokyo", state: "TYO" }
    ],
    countries: [
        { code: "USA", countryName: "United States" },
        { code: "JPN", countryName: "Japan" }
    ]
};


try {
    // MULTI-LINE QUERY TEST
    const leftJoinQuery = `    SELECT friends.name, cities.cityName, countries.countryName
FROM data.friends
JOIN data.cities ON city = cityName
JOIN data.countries ON countryCode = code`;


    console.log(formatAsMySQLTable(executeQuery(leftJoinQuery, data)));
} catch (err) {
    console.error("SQL Error: " + err.message);
    // Output: SQL Error: Table does not exist: data.wrong_table
}